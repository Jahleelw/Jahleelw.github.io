<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夜里的狸猫</title>
  
  <subtitle>black eyes</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jahleelw.github.io/"/>
  <updated>2019-12-03T03:36:16.003Z</updated>
  <id>https://jahleelw.github.io/</id>
  
  <author>
    <name>jal</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>傻瓜式的LinuxU盘自动挂载-C语言</title>
    <link href="https://jahleelw.github.io/2019/12/02/%E5%82%BB%E7%93%9C%E5%BC%8F%E7%9A%84LinuxU%E7%9B%98%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD-C%E8%AF%AD%E8%A8%80/"/>
    <id>https://jahleelw.github.io/2019/12/02/%E5%82%BB%E7%93%9C%E5%BC%8F%E7%9A%84LinuxU%E7%9B%98%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD-C%E8%AF%AD%E8%A8%80/</id>
    <published>2019-12-02T08:02:01.000Z</published>
    <updated>2019-12-03T03:36:16.003Z</updated>
    
    <content type="html"><![CDATA[<h4 id><a href="#" class="headerlink" title></a></h4><h4 id="能work就行"><a href="#能work就行" class="headerlink" title="能work就行"></a>能work就行</h4><p>目的很简单，插上U盘后能自动挂载，但加点小要求：第一，挂载的目录要在/media上。第二，挂载的目录名要和系统识别U盘的名字一样。比如，我有一个三个区的U盘，怼入后fdisk -l看一下看到它为/dev/sdb1\2\3，那么正常来讲，它应该挂载到/media/sdb1\2\3目录。</p><p>那基于这个目标，撸起袖子干。本来linux内置udev服务可以完美解决。但参考一堆教程配置来配置去有各种奇奇怪怪的问题达不到预期目的。外加上由于这个是小系统被剪过（从2G剪到550M的fedora…），缺了什么咱们还真不确定。</p><p>至此，一个低端的自动挂载程序想法悄咪咪的生成。但求能work out。</p><a id="more"></a><h4 id="思路与想法"><a href="#思路与想法" class="headerlink" title="思路与想法"></a>思路与想法</h4><p>简单的说，就是不断检查系统硬盘分区，多了就加，少了就减。</p><p>当然这是个特例，因为目标系统定死了首先它只有一个硬盘装的是系统，也就是sda。其次它如果有新的硬盘进入系统，也只能是U盘。</p><p>所以分三块：</p><ol><li>流程控制，控制执行频率和挂载卸载执行分支；</li><li>查看系统硬盘状态，并得到相应数据；</li><li>生成硬盘信息数据结构，同步挂载卸载；</li></ol><p>流程控制，简单的采用while(1)和sleep控制，采用数据对比每番进行判断；<br>硬盘状态，在/proc/partitions可以读取，再加个wc -l细化处理可以简单得到当前硬盘数；<br>数据结构，由于每个硬盘可能有几个区，而代表每个区的是字符串结构，符合这种直接用二位数组，再由于顺序没有特别的重要，善用字符串比较和下标就行，所以总的来说算是一个比较离散的二维数组吧。</p><p>上流程图：</p><div align="center"><p><img src="/2019/12/02/%E5%82%BB%E7%93%9C%E5%BC%8F%E7%9A%84LinuxU%E7%9B%98%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD-C%E8%AF%AD%E8%A8%80/amount_pic_1.jpg" alt="流程图"></p></div><p>由于也只有一条线程，也不用考虑数据的冲突，就一路往下跑就是了。</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>细想整个流程最重要的部分，也就是有一个全局的二维数组来记录着当前挂载了的硬盘。<br>每当硬盘有变动，这个二维数组就产生相应的变化，那具体的增删，是有点点类似队列但又不是，因为你无法判断是哪个先出（是哪个磁盘先拔出来），考虑过链表，不过总共才四五个USB口用数组它不香吗。</p><p>那么假设现在挂载了个三个分区的U盘B，sdb1，sdb2，sdb3，那么在这个全局数组中数据应该是这样的：<br><img src="/2019/12/02/%E5%82%BB%E7%93%9C%E5%BC%8F%E7%9A%84LinuxU%E7%9B%98%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD-C%E8%AF%AD%E8%A8%80/data_pic_1.png" alt="数组1"></p><p>这时如果先插入两个分区的U盘C和一个分区的U盘D，它应该会进行添加即：<br><img src="/2019/12/02/%E5%82%BB%E7%93%9C%E5%BC%8F%E7%9A%84LinuxU%E7%9B%98%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD-C%E8%AF%AD%E8%A8%80/data_pic_1.png" alt="数组1">  —&gt;   <img src="/2019/12/02/%E5%82%BB%E7%93%9C%E5%BC%8F%E7%9A%84LinuxU%E7%9B%98%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD-C%E8%AF%AD%E8%A8%80/data_pic_2.png" alt="数组2">   —&gt;   <img src="/2019/12/02/%E5%82%BB%E7%93%9C%E5%BC%8F%E7%9A%84LinuxU%E7%9B%98%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD-C%E8%AF%AD%E8%A8%80/data_pic_3.png" alt="数组3"></p><p>而如果此时拔出U盘C，它该进行如下减少并调整：<br><img src="/2019/12/02/%E5%82%BB%E7%93%9C%E5%BC%8F%E7%9A%84LinuxU%E7%9B%98%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD-C%E8%AF%AD%E8%A8%80/data_pic_3.png" alt="数组3">   —&gt;   <img src="/2019/12/02/%E5%82%BB%E7%93%9C%E5%BC%8F%E7%9A%84LinuxU%E7%9B%98%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD-C%E8%AF%AD%E8%A8%80/data_pic_4.png" alt="数组4">   —&gt;   <img src="/2019/12/02/%E5%82%BB%E7%93%9C%E5%BC%8F%E7%9A%84LinuxU%E7%9B%98%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD-C%E8%AF%AD%E8%A8%80/data_pic_5.png" alt="数组5"></p><p>添加的时候是从尾部添加，删除时及时移位进行前面的空位补全。其中有一个对应的全局变量记录着当前挂载的硬盘数，可以用作这个全局数组的下标进行处理。</p><h4 id="代码层级"><a href="#代码层级" class="headerlink" title="代码层级"></a>代码层级</h4><p>从代码层级上说，从上往下简要的几个重要部份。<br>宏定义和全局，全局也就上述提到那俩~</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PARTITION_CNT_MAX50<span class="comment">//最大接入硬盘数，稍微给大点没事</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PARTITION_LEN_SIZE5<span class="comment">//最大分区名字长度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLEEP_TIME_US1000*500<span class="comment">//睡眠时间，等于是频率</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SIZE1024*4<span class="comment">//取得数据中转缓存</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMD_SIZE100<span class="comment">//存放Linux命令缓存</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SIZE_MINOR10<span class="comment">//取得数据中转小缓存</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAST_DISK_POINT  <span class="meta-string">"sda1"</span><span class="comment">//固有硬盘的最后一个，往下都是添加的</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NORMAL_DISK_NUM4<span class="comment">//没新接硬盘时的正常/proc/partitions行数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG<span class="comment">//调试开关</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> g_disk_mount[PARTITION_CNT_MAX][PARTITION_LEN_SIZE] = &#123;<span class="number">0</span>&#125;;  </span><br><span class="line"><span class="keyword">int</span> g_disk_mount_cnt = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><hr><p>一开始先检查硬盘数目，将数据转化成自己想要的信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_Disk_Num</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> disk_num;</span><br><span class="line"><span class="keyword">char</span> buff[BUFF_SIZE_MINOR] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> cmd[CMD_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sprintf</span>(cmd, <span class="string">"cat /proc/partitions | wc -l"</span>);</span><br><span class="line">FILE *fp = popen(cmd, <span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">while</span>( fgets(buff, BUFF_SIZE_MINOR<span class="number">-1</span>, fp) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">disk_num = atoi(buff);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"check disk num:  %d\n"</span>, disk_num);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">pclose(fp);</span><br><span class="line"><span class="keyword">return</span> disk_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>每当检测到硬盘数目增加，会先取得增加的硬盘名字列表，保存在disk[]这个数组里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = <span class="built_in">strstr</span>(buff,LAST_DISK_POINT);</span><br><span class="line"><span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    disk_partition_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (disk_partition_cnt &gt;= PARTITION_CNT_MAX)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        p = <span class="built_in">strstr</span>(p + <span class="number">4</span>,<span class="string">"sd"</span>);</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//get mount disk list</span></span><br><span class="line">            <span class="built_in">memset</span>(disk[disk_partition_cnt], <span class="number">0</span>, PARTITION_LEN_SIZE);</span><br><span class="line">            <span class="built_in">memcpy</span>(disk[disk_partition_cnt], p, <span class="number">4</span>); </span><br><span class="line">            change_Enter(disk[disk_partition_cnt]);</span><br><span class="line">            disk_partition_cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>得到数组列表，判断下是否单分区是否已存在，进行全局数据添加操作和系统挂载：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//judge and add to global</span></span><br><span class="line">disk_mount_cnt_temp = g_disk_mount_cnt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; disk_partition_cnt; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (disk_Is_Exit(disk[i]))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if len=3 disk have no partition</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(disk[i]) == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !disk_Is_Single_Partition(disk[i]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(g_disk_mount[g_disk_mount_cnt], disk[i], <span class="built_in">strlen</span>(disk[i]));</span><br><span class="line">    g_disk_mount_cnt++;</span><br><span class="line">&#125;</span><br><span class="line">run_Mount(g_disk_mount_cnt - disk_mount_cnt_temp);</span><br></pre></td></tr></table></figure><hr><p>根据获取的实际挂载磁盘信息和全局数组进行比对，如果发现实际的少了些，那要进行卸载和全局数组调整删除操作了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g_disk_mount_cnt; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(buff,g_disk_mount[i]) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cmd, <span class="number">0</span>, CMD_SIZE);</span><br><span class="line">        <span class="built_in">sprintf</span>(cmd,<span class="string">"umount /media/%s"</span>,g_disk_mount[i]);</span><br><span class="line">        <span class="keyword">if</span> ( <span class="number">0</span> != run_System_Cmd(cmd))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(cmd, <span class="number">0</span>, CMD_SIZE);</span><br><span class="line">            <span class="built_in">sprintf</span>(cmd,<span class="string">"umount /media/%s -l"</span>,g_disk_mount[i]);</span><br><span class="line">            run_System_Cmd(cmd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(cmd, <span class="number">0</span>, CMD_SIZE);</span><br><span class="line">        <span class="built_in">sprintf</span>(cmd, <span class="string">"rm /media/%s -rf"</span>, g_disk_mount[i]);</span><br><span class="line">        run_System_Cmd(cmd);</span><br><span class="line"></span><br><span class="line">        disk_umount_pos[disk_umount_cnt] = i;</span><br><span class="line">        disk_umount_cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>卸载系统里已经没有了的硬盘后，进行数组的清除和移位操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//clear the umount disk from global</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; disk_umount_cnt; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (disk_umount_pos[i] == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(g_disk_mount[disk_umount_pos[i]], <span class="number">0</span>, PARTITION_LEN_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//reset the global</span></span><br><span class="line">g_disk_mount_cnt = g_disk_mount_cnt - disk_umount_cnt;</span><br><span class="line"><span class="keyword">int</span> temp_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PARTITION_CNT_MAX; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (temp_cnt == g_disk_mount_cnt)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(g_disk_mount[i]) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(g_disk_mount[temp_cnt], g_disk_mount[i], PARTITION_LEN_SIZE);</span><br><span class="line">        temp_cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = temp_cnt; i &lt; PARTITION_CNT_MAX; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g_disk_mount[i], <span class="number">0</span>, PARTITION_LEN_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要操作就这么多，当然还有很多细代码块，实现的方法也有很多。<br>还是那句话，能work就行。。。</p><h4 id="终语"><a href="#终语" class="headerlink" title="终语"></a>终语</h4><p>是有点儿low的，不过的确也能按照要求完成任务，最起码baseline是达到的。<br>还是挺感概这个哈皮方法能上的了台~毕竟当初记得有一个作业，说把开发板作为一个电子相册，插入满是图片的U盘时开发版自动挂载U盘并显示图片出来。<br>哈哈哈如今竟然用到了，只不过别人变成了实际的用处，用在哪咱也不知道也不敢问，但完成底层的挂卸载管他怎么操作呢。</p><p>最后放上挂卸载时程序消耗图吧和一个服务检测这个程序会不会挂掉，挂掉就拉起来：<br><img src="/2019/12/02/%E5%82%BB%E7%93%9C%E5%BC%8F%E7%9A%84LinuxU%E7%9B%98%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD-C%E8%AF%AD%E8%A8%80/automount_cost.png" alt="耗费资源"></p><p>鹅还有哈皮代码：<br><a href="/download/automount.c" ">automount</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;/h4&gt;&lt;h4 id=&quot;能work就行&quot;&gt;&lt;a href=&quot;#能work就行&quot; class=&quot;headerlink&quot; title=&quot;能work就行&quot;&gt;&lt;/a&gt;能work就行&lt;/h4&gt;&lt;p&gt;目的很简单，插上U盘后能自动挂载，但加点小要求：第一，挂载的目录要在/media上。第二，挂载的目录名要和系统识别U盘的名字一样。比如，我有一个三个区的U盘，怼入后fdisk -l看一下看到它为/dev/sdb1\2\3，那么正常来讲，它应该挂载到/media/sdb1\2\3目录。&lt;/p&gt;
&lt;p&gt;那基于这个目标，撸起袖子干。本来linux内置udev服务可以完美解决。但参考一堆教程配置来配置去有各种奇奇怪怪的问题达不到预期目的。外加上由于这个是小系统被剪过（从2G剪到550M的fedora…），缺了什么咱们还真不确定。&lt;/p&gt;
&lt;p&gt;至此，一个低端的自动挂载程序想法悄咪咪的生成。但求能work out。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://jahleelw.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="linux" scheme="https://jahleelw.github.io/tags/linux/"/>
    
      <category term="C" scheme="https://jahleelw.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>树莓派hexo辛酸史</title>
    <link href="https://jahleelw.github.io/2019/11/28/%E6%A0%91%E8%8E%93%E6%B4%BEhexo%E8%BE%9B%E9%85%B8%E5%8F%B2/"/>
    <id>https://jahleelw.github.io/2019/11/28/%E6%A0%91%E8%8E%93%E6%B4%BEhexo%E8%BE%9B%E9%85%B8%E5%8F%B2/</id>
    <published>2019-11-28T10:09:04.000Z</published>
    <updated>2019-12-02T07:41:06.886Z</updated>
    
    <content type="html"><![CDATA[<h4 id="折腾不息，生命不止"><a href="#折腾不息，生命不止" class="headerlink" title="折腾不息，生命不止"></a>折腾不息，生命不止</h4><p>那天看见房间里的一角里面的那<del>寂寞的</del>吃灰的树莓派，于心不忍。</p><p>恰好那时听一个很牛逼的鹅厂师兄的讲座，说他有用hexo博客。</p><p>加上一个看到一个心动的博客介绍指导 <a href="https://www.simon96.online/2018/10/12/hexo-tutorial/" target="_blank" rel="noopener">遇见西门</a></p><p>我突然涌起一股想用这个卡片搭一个hexo博客的想法！（激情澎湃）</p><a id="more"></a><h4 id="树莓派系统与登录"><a href="#树莓派系统与登录" class="headerlink" title="树莓派系统与登录"></a>树莓派系统与登录</h4><p>之前曾经在树莓派上配置了一些文件自动拨号并作为一个无线路由，结果换了网络后再也连不上它了。</p><p>一开机就在那使劲拨号我也很绝望。。。只能重装系统了是吧。</p><p>装树莓派系统还是很多很多教程也比较容易的，<a href="https://blog.csdn.net/yzy_1996/article/details/82916940" target="_blank" rel="noopener">这里按照了这个</a>。只不过这个镜像资源实在太太太难找了吧，国内镜像网找不到，一些奇奇怪怪的网址有是有但也不敢下啊，<del>官网镜像慢得一</del>。后来发现在官网只下种子然后用迅雷打开，发现了新大陆！</p><p><a href="https://blog.csdn.net/weixin_43336281/article/details/97373288" target="_blank" rel="noopener">装上系统第一件事就是换源</a>，换完后立刻update，为后续做准备。</p><p>登录的话有putty啦vnc啦win的远程啦，可我就不同，我要teamview，我贪用teamview的远程。</p><p><a href="https://blog.csdn.net/realdonaldtrump/article/details/79694196" target="_blank" rel="noopener">轮子还是有的</a>，teamview尽量下15吧毕竟出事不久。但还是有坑，在辣个晚上，我按照所有教程设置了teamview密码在查看info中去连那个ID，连不上很绝望。那时无意的一点teamview图形界面启动看见了图形界面的ID和teamviewer –info显示的ID是不同的，连那个图形的突然就行了。</p><p>可是在卡片上运行这个的性能和速度，<del>谁用谁知道</del></p><h4 id="部署hexo"><a href="#部署hexo" class="headerlink" title="部署hexo"></a>部署hexo</h4><p>关键还是要有nodejs和npm啦，好吧还是找<a href="https://www.cnblogs.com/imapla/p/5532985.html" target="_blank" rel="noopener">轮子</a>，这里注意树莓派的架构版本，我的是3b，uname一下发现是arm7l，下载对应的版本即可。搭建按照遇见西门教程没有问题，hexo s然后上浏览器一看它出来鸟！！！（泪流满面）</p><p>后面的一切操作，什么主题，插件，文章，githubpage，啊哈都是支持的！</p><h4 id="其实"><a href="#其实" class="headerlink" title="其实"></a>其实</h4><p>其实没有必要。。</p><p>这个用派来搞有一个最大的愿景就是方便吧？比如我能随时随地写博客因为我能随时随地带着卡片，可如今云辣么多这种可携带性还有没有意义呢。</p><p>不管有没有意义，这卡片卡死了好几遍。这个是硬伤。</p><p>但折腾一下，就是其本身的魅力，尽管我已经放弃它了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;折腾不息，生命不止&quot;&gt;&lt;a href=&quot;#折腾不息，生命不止&quot; class=&quot;headerlink&quot; title=&quot;折腾不息，生命不止&quot;&gt;&lt;/a&gt;折腾不息，生命不止&lt;/h4&gt;&lt;p&gt;那天看见房间里的一角里面的那&lt;del&gt;寂寞的&lt;/del&gt;吃灰的树莓派，于心不忍。&lt;/p&gt;
&lt;p&gt;恰好那时听一个很牛逼的鹅厂师兄的讲座，说他有用hexo博客。&lt;/p&gt;
&lt;p&gt;加上一个看到一个心动的博客介绍指导 &lt;a href=&quot;https://www.simon96.online/2018/10/12/hexo-tutorial/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;遇见西门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我突然涌起一股想用这个卡片搭一个hexo博客的想法！（激情澎湃）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="树莓派" scheme="https://jahleelw.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="技术" scheme="https://jahleelw.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="hexo" scheme="https://jahleelw.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>释然</title>
    <link href="https://jahleelw.github.io/2019/11/27/the-break-heard/"/>
    <id>https://jahleelw.github.io/2019/11/27/the-break-heard/</id>
    <published>2019-11-27T01:20:01.000Z</published>
    <updated>2019-11-28T02:54:07.291Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="Hey, password is required here." />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="7b73a1dab6bed8ef163aa872e461e11316b3f223ee265455928e22647a9957ec">b31e22a21472225c8a0a855f3e97ce9495f34f984deb7bbb51c1b2292eb303fa83d842ef848a1afe786c0e95da05ec91b370efc0dc4121f58e6ace6d1d9a0879cd9a897a7e08f3a1a9e202ad35052c50</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://jahleelw.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
